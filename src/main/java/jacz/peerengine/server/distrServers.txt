Modelo de peer servers distribuidos
-----------------------------------

Alberto
24-Sep-2010


En este documento se recoge una descripción para un modelo distribuido de peer servers. Este modelo responde a la
necesidad de distribuir la carga de trabajo de los servidores en distintos nodos. Dichos nodos trabajan de forma
independiente, pero pueden compartir información.

El modelo debe ser capaz de permitir a usuarios encontrarse entre sí, dando como dato tan sólo un identificador
(un valor de seguramente 128 bits). Sería deseable también que permitiese la búsqueda de otros usuarios mediante
cadenas de caracteres (o mejor, valores customizables).

Los servidores deberán además implementar mecanismos de autenticación de usuarios, ya que el modelo de peer client se
basa en un sistema sin contraseña, pero conteniendo pares clase pública/privada, donde un resourceID de la clave pública
actúa como identificador del usuario.

El principal reto del modelo de peer servers es que sean capaces de distribuir la carga de trabajo correspondiente a
gestionar las conexiones de un gran número de clientes, pero a la vez poder trabajar de forma independiente, con
tolerancia a fallo en algunos de los nodos servidores. Para esto se define el reparto de PeerIDs. Cada servidor
tendrá un rango asignado de IDs con los que trabajará. Este reparto debe ser conocido por todos los servidores, para
así poder redirigir a los clientes a sus servidores asignados. Por supueto, estos rangos solaparán entre sí, para
que un cliente siempre tenga varios servidores posibles a los que conectarse.

Estos repartos deben ser flexibles y capaces de evolucionar en el tiempo para adaptarse a las necesidades de la red
de peers, y/o a la aparición y desaparición de nodos servidores. Debido a que no existe un nodo central, los propios
servidores deberán calcular los rangos más adecuados para si mismos (por supuesto, se podrá configurar la cantidad
de IDs a las que se desea dar servicio).

En primer lugar, es imprescindible que cada servidor sepa de la existencia de todos los demás servidores, y conocer
el reparto de IDs de toda la red. Cada servidor tiene su propia ID, como los clientes, permitiendo así identificarse
ante los demás servidores (y autenticarse). Por lo menos, debe asegurarse que la red de servidores no forma un
grafo inconexo, con islas independientes. De aquí se definen dos approaches: conocimiento total / conocimiento parcial.

Conocimiento total: cada servidor disponde de los datos de TODOS los sevidores conectados, y mantiene conexiones con
todos ellos (para así tener siempre información actualizada). Un nuevo servidor deberá simplemente pedirle los datos
de todos los servidores a uno cualquiera, y con eso podrá empezar a funcionar.

  Ventajas: los servidores disponen de toda la información que les es necesaria, basta conectarse a un servidor para
  tener toda la información y redirigir a clientes a sus servidores correspondientes es sencillo.

  Desventajas: este approach puede presentar problemas de eficiencia si existen gran cantidad de servidores que
  se ocupan de pocos clientes. Si tenemos 10000 servidores, se genera una grandisima cantidad de tráfico sólo por
  estar conectado a todos ellos y mantener su información actualizada. Cada servidor que se conecta afecta a todos
  los demás servidores. Puede que servidores poco potentes no aguanten bien la carga.

Conocimiento parcial: cada servidor conoce sólo una parte de la red de servidores, pero lo suficiente para que esta
forme una red conexa.

  Ventajas: menos carga de trabajo para los servidores


El approach de conocimiento parcial se perfila más adecuado para este problema, pero a su vez presenta mayores
dificultades en la implementación. Queda ver cuánta información de otros servidores (y de cuales) tendría un servidor.
Aún habría que asegurarse de que se cumple la hipótesis de red de servidores conexa.



IDEA: un nuevo nivel de servidores, que sirven a los servidores normales: Master Peer Servers. Estos contienen
información sobre los peer servers, pero no sirven peticiones de clientes (por tanto se reduce en gran cantidad su
carga de trabajo). Deberían siempre conecerse todos entre sí (conocimiento total en su propio nivel) y conocer siempre
a todos los servidores (con. total en el nivel inferior). Esto permitiría incluso no necesitar una red de servidores
conexa. Los Peer Servers podrían sólo saber de los otros servidores con los que solapan, facilitando así el approach
de conocimiento parcial.

problema: los clientes necesitan saber a qué servidores dirigirse para encontrar otros clientes. A quién le preguntan
esto? A los Master Peer Servers? Es la opción más sencilla, pero entonces le damos una mayor carga de trabajo a estos,
y es justo lo que queremos evitar. De todas formas serían peticiones sencillas, y no tantas... y no tendrían que
guardar datos de clientes en memoria -> ahorro en memoria importante. Otra opción es que los peer servers hagan de
intermediarios, y ellos resuevan ese tipo de peticiones de los clientes. La información realmente se la pedirán a
un master peer server, pero se la guardarán para futuras consultas (y la actualizarán si el cliente le dice que eso
no le ha funcionado). Esto mola más. Da el máximo grado de escalabilidad, los master peer servers se concentran en
su misión, etc.



Información personal para buscar usuarios
-----------------------------------------

Se desea permitir a clientes buscar a otros clientes por información sobre estos (p ej: nick). La idea sería permitir a
clientes que subiesen datos personales de sí mismos de cualquier clase, y que otros clientes pudiesen buscar
coincidencias para encontrar amigos. Esto supone un gran gasto de memoria a los peer servers, pero es muy útil.

De nuevo, estos datos deberían repartirse entre servidores. Sin embargo es complicado hacer la partición aquí, ya que
no hay una ordenación para estos datos como la hay para los peer id. Tal vez deberían restringirse un poco los tipos
de datos que se pueden emplear, para así posibilitar esta ordenación. P ej buscar con palabras completas, y números.
O bien, prefijos de palabras. Si sólo se usan estos dos tipos, es fácil hacer la ordenación. Para palabras, se puede
dividir por los dos primeros caracteres (ej: las palabras que empiezen por "aa" forman un elemento, hasta "zz").

Tal vez podríamos fijarlo sólo a strings, para hacerlo más sencillo. 